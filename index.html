<!DOCTYPE html>
<html lang="pl">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mouse Tester - Double Click, Scroll jumps, Pool rate test</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-SgOJa3DmI69IUzQ2PVdRZhwQ+dy64/BUtbMJw1MZ8t5HZApcHrRKUc4W0kG879m7" crossorigin="anonymous">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f4f4f4;
      user-select: none;
      width: 100%;
      margin: 10px auto;
    }

    .testarea {
      width: 800px;
      height: 400px;
      padding: 0;
      font-size: 16px;
      cursor: pointer;
      border: none;
      border-radius: 10px;
      color: white;
      font-size: 25px;
      font-weight: bold;
      margin-bottom: 35px;
      transition: 100ms;
    }

    .testarea-text {
      display: flex;
      background-color: #007bff;
      width: 100%;
      height: 100%;
      transition: 100ms;
      border-radius: 10px;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .testarea-text:hover {
      background-color: #007bffaa;
      border-radius: 10px;
      opacity: 0.7;
    }

    .counter {
      width: 85%;
      display: flex;
      padding: 10px;
      flex-direction: column;
      justify-content: center;
      background-color: #ffffff;
      border-radius: 5px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      align-items: center;
    }

    .reset {
      padding: 10px 15px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      background-color: #007bff;
      margin: 15px;
      color: white;
      transition: 400ms;
    }

    .reset:hover {
      background-color: #ff00006e;
      opacity: 0.5;
    }

    p {
      font-size: 18px;
      margin: 10px 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .arrow {
      font-size: 24px;
      margin-left: 10px;
    }

    .error {
      color: red;
      font-size: 1.2rem;
      font-weight: bold;
    }

    .mouse {
      width: 200px;
      height: 400px;
      background: linear-gradient(to bottom, #949494, #9e9e9e);
      border-radius: 80px 80px;
      transform: translate(0%, 0%);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }

    .wheel {
      width: 13%;
      height: 23%;
      position: absolute;
      top: 17%;
      left: 50%;
      transform: translate(-50%, -50%);
      border-radius: 15px;
      border: 2px solid #848484;
    }

    .left-button,
    .right-button {
      width: 50%;
      height: 49%;
      position: absolute;
      border-bottom: 2px solid #848484;
      top: 0px;
    }

    .left-button {
      left: 0px;
      border-radius: 80px 0 0 0;
      border-right: 1px solid #848484;
    }

    .right-button {
      right: 0px;
      border-radius: 0 80px 0 0;
      border-left: 1px solid #848484;
    }

    .side-buttons {
      width: 3%;
      height: 25%;
      position: absolute;
      top: 50%;
      left: -1%;
      transform: translate(-50%, -50%);
      border-radius: 15px 0 0 15px;
      border: 1px solid #848484;
    }

    .back-side-button {
      width: 100%;
      height: 50%;
      border-bottom: 1px solid #848484;
    }

    .next-side-button {
      width: 100%;
      height: 50%;
      border-top: 1px solid #848484;
    }

    .RollerCoaster {
      color: #ffb100;
      font-size: 40px;
      text-align: center;
    }

    .clicker {
      display: flex;
      flex-direction: row;
      justify-content: space-evenly;
      align-items: stretch;
      width: 85%;
    }

    .allitems {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    /* Styl powiadomień o osiągnięciach */
    .achievement-popup {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background-color: #007bff;
      color: white;
      padding: 10px 20px;
      margin-bottom: 10px;
      border-radius: 5px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      position: relative;
      animation: slide-in 0.5s ease forwards;
      /* Animacja wysuwania */
    }

    .achievement-popup img {
      width: 40px;
      height: 40px;
      margin-right: 10px;
    }

    .achievement-popup .text {
      flex-grow: 1;
    }

    .achievement-popup .close {
      cursor: pointer;
      font-size: 20px;
      margin-left: 10px;
    }

    @keyframes slide-in {
      from {
        transform: translateX(100%);
        opacity: 0;
      }

      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes fade-out {
      to {
        opacity: 0;
      }
    }

    /* Animacja chowania */
    @keyframes slide-out {
      from {
        transform: translateX(0);
        opacity: 1;
      }

      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }

    /* Styl fajerwerków */
    .firework {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: #ffcc00;
      border-radius: 50%;
      animation: explode 1s ease-out forwards;
    }

    @keyframes explode {
      0% {
        transform: scale(1);
        opacity: 1;
      }

      100% {
        transform: scale(3);
        opacity: 0;
      }
    }
  </style>
</head>

<body>
  <div class="allitems">
    <div class="row clicker">
      <div class="col-4 me-5 mouse">
        <div id="LeftMouseButton" class="left-button"></div>
        <div id="RightMouseButton" class="right-button"></div>
        <div id="MiddleMouseButton" class="wheel">
          <div id="RollerCoaster" class="RollerCoaster">↑</div>
        </div>
        <div class="side-buttons">
          <div id="BackMouseButton" class="back-side-button"></div>
          <div id="NextMouseButton" class="next-side-button"></div>
        </div>
      </div>
      <button class="col testarea" id="testarea">
        <div class="testarea-text" id="testareaText">
          <span>Klikaj lub scrolluj!</span>
        </div>
      </button>
    </div>

    <div class="counter">
      <div class="row align-items-center m-auto w-100 bg-body-secondary rounded">
        <div class="col">
          <p>
            LMB:<span id="lpm-clickcounter">&nbsp;0</span>
            <span id="lpm-diff"></span>
          </p>
          <p id="lpm-error" class="error"></p>
          <p></p>
          <p>
            MMB:<span id="spm-clickcounter">&nbsp;0</span>
            <span id="spm-diff"></span>
          </p>
          <p id="spm-error" class="error"></p>
          <p></p>
          <p>
            RMB:<span id="ppm-clickcounter">&nbsp;0</span>
            <span id="ppm-diff"></span>
          </p>
          <p id="ppm-error" class="error"></p>
          <p></p>
        </div>
        <div class="col">
          <p>
            Back:<span id="back-clickcounter">&nbsp;0</span>
            <span id="back-diff"></span>
          </p>
          <p id="back-error" class="error"></p>
          <p></p>
          <p>
            Next:<span id="next-clickcounter">&nbsp;0</span>
            <span id="next-diff"></span>
          </p>
          <p id="next-error" class="error"></p>
          <p></p>
        </div>
        <div class="col">
          <p>Scroll ↑:<span id="scroll-up-counter">&nbsp;0</span></p>
          <p>Scroll ↓:<span id="scroll-down-counter">&nbsp;0</span></p>
          <p>
            Kierunek:<span id="scroll-direction">&nbsp;Scroll!!</span>
            <span id="scroll-arrow" class="arrow"></span>
          </p>
          <p id="scroll-error" class="error"></p>
        </div>
      </div>
      <div class="row d-flex align-items-center m-auto width-100">
        <div class="col">
          <span id="debouncetext">Debounce Time: 0.00s </span>
        </div>
        <div class="col-3">
          <input type="number" min="0" max="30" id="debounceSet" /><span>
            0-30</span>
        </div>
        <div class="col-6 align-items-center d-flex justify-content-center">
          <button class="reset" onclick="setDebounceTime()">SET</button>
          <button class="reset" onclick="reloadPage()">RESET</button>
        </div>
      </div>
    </div>

    <div class="row counter mt-4">
      <div class="align-items-center m-auto bg-body-secondary rounded">
        <div class="row" style="
              display: flex;
              align-items: center;
              justify-content: space-evenly;
              flex-direction: row;
            ">
          <p id="hZmeter" class="mt-2">
            Pomiar częstotliwości myszy. Kliknij aby rozpocząć!
          </p>
          <button class="reset" id="meterButton" style="max-width: 50%" onclick="checkRate()">
            Kliknij aby rozpocząć pomiar!
          </button>
        </div>
        <canvas style="display: none" id="myChart" class="align-items-center justify-content-center"></canvas>
      </div>
    </div>
    <div class="row d-flex justify-content-center mt-3">
      <button class="reset" id="showAchievementsButton" onclick="showAchievementsModal()">Pokaż odblokowane
        osiągnięcia</button>
    </div>
  </div>
  <!-- Powiadomienia o osiągnięciach -->
  <div id="achievement-popup-container" style="position: fixed; top: 20px; right: 20px; z-index: 1000;"></div>

  <!-- Fajerwerki -->
  <div id="fireworks-container"
    style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 999;"></div>
  <!-- Modal Bootstrap do wyświetlania osiągnięć -->
  <div class="modal fade" id="achievementsModal" tabindex="-1" aria-labelledby="achievementsModalLabel"
    aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="achievementsModalLabel">Odblokowane osiągnięcia</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Zamknij"></button>
        </div>
        <div class="modal-body">
          <ul id="achievements-list" class="list-group">
            <!-- Lista osiągnięć zostanie wygenerowana dynamicznie -->
          </ul>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-danger" onclick="resetAchievements()">Zresetuj osiągnięcia</button>
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Zamknij</button>
        </div>
      </div>
    </div>
  </div>
  <script src="https://code.jquery.com/jquery-3.7.1.slim.min.js"
    integrity="sha256-kmHvs0B+OpCW5GVHUNjv9rOmY0IvSIRcf7zGUDTDQM8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
    crossorigin="anonymous"></script>
  <script>
    // Get the elements by their IDs
    const LPMCounter = document.getElementById("lpm-clickcounter");
    const PPMCounter = document.getElementById("ppm-clickcounter");
    const scrollUpCounter = document.getElementById("scroll-up-counter");
    const scrollDownCounter = document.getElementById("scroll-down-counter");
    const scrollDirection = document.getElementById("scroll-direction");
    const scrollArrow = document.getElementById("scroll-arrow");
    const scrollError = document.getElementById("scroll-error");
    const LPMError = document.getElementById("lpm-error");
    const PPMError = document.getElementById("ppm-error");
    const LPMDiff = document.getElementById("lpm-diff");
    const PPMDiff = document.getElementById("ppm-diff");
    const mouseSection = document.getElementById("testarea");
    const SPMCounter = document.getElementById("spm-clickcounter");
    const SPMDiff = document.getElementById("spm-diff");
    const SPMError = document.getElementById("spm-error");
    const backCounter = document.getElementById("back-clickcounter");
    const backDiff = document.getElementById("back-diff");
    const backError = document.getElementById("back-error");
    const nextCounter = document.getElementById("next-clickcounter");
    const nextDiff = document.getElementById("next-diff");
    const nextError = document.getElementById("next-error");
    //mouseButtons
    const LPMButton = document.getElementById("LeftMouseButton");
    const PPMButton = document.getElementById("RightMouseButton");
    const SPMButton = document.getElementById("MiddleMouseButton");
    const backButton = document.getElementById("BackMouseButton");
    const nextButton = document.getElementById("NextMouseButton");
    const scrollRoller = document.getElementById("RollerCoaster");
    //clicks
    let clickDiffLPM = 0;
    let clickDiffPPM = 0;
    let LPMClicks = 0;
    let PPMClicks = 0;
    let scrollUp = 0;
    let scrollDown = 0;
    let scrollDirectionChanges = 0;
    let lastScrollDirection = null;
    let prevClickMicrotimeLPM = 0;
    let prevClickMicrotimePPM = 0;
    let prevScrollDirectionChangeTime = microtime(true);
    let clickDiffVariable;
    let isLPMPressed = false;
    let isPPMPressed = false;
    let LPMDouble = 0;
    let PPMDouble = 0;
    let SPMDouble = 0;
    let SPMClicks = 0;
    let clickDiffSPM = 0;
    let isSPMPressed = false;
    let prevClickMicrotimeSPM = 0;
    let backDouble = 0;
    let backClicks = 0;
    let clickDiffback = 0;
    let isbackPressed = false;
    let prevClickMicrotimeback = 0;
    let nextDouble = 0;
    let nextClicks = 0;
    let clickDiffnext = 0;
    let isnextPressed = false;
    let prevClickMicrotimenext = 0;
    let debounceTime;
    //hZmeter
    let count = 0;
    let tick = 0;
    let totalMoves = 0;
    let value = 0;
    let timer = null;
    let chartTimer = null;
    let testTimeout = null;
    let meterSeconds = 0;
    let lastTime = performance.now();
    // Inicjalizacja wykresu
    const ctx = document.getElementById("myChart").getContext("2d");
    const chartData = {
      labels: [],
      datasets: [
        {
          label: "Częstotliwość (Hz)",
          data: [],
          borderColor: "rgba(0, 123, 255, 1)",
          backgroundColor: "rgba(0, 123, 255, 0.2)",
          borderWidth: 2,
          fill: true,
        },
      ],
    };
    const myChart = new Chart(ctx, {
      type: "line",
      data: chartData,
      options: {
        responsive: true,
        animation: {
          duration: 100,
          easing: "easeInQuad",
        },
        scales: {
          x: {
            title: {
              display: true,
              text: "Czas (s)",
            },
          },
          y: {
            title: {
              display: true,
              text: "Częstotliwość (Hz)",
            },
            beginAtZero: true,
            min: 0, // Minimalna wartość osi Y
            max: 1000, // Maksymalna wartość osi Y
          },
        },
      },
    });
    function reloadPage() {
      window.location.reload();
    }
    function setDebounceTime() {
      // Pobranie wartości z pola i skonwertowanie jej na liczbę
      if (document.getElementById("debounceSet").value > 0) {
        debounceTime = document.getElementById("debounceSet").value / 100;
      } else {
        debounceTime = 10 / 100;
      }
      document.getElementById("debouncetext").innerHTML =
        "Debounce Time: " + debounceTime + "s ";
      // Wyświetlenie wartości w konsoli
      console.log(debounceTime);
    }
    function handleMouseClick(
      button,
      incrementClicks,
      errorElement,
      diffElement,
      prevClickMicrotime
    ) {
      let isDoubleClick = clickEvent(prevClickMicrotime);
      if (isDoubleClick) {
        if (button === 0) {
          LPMDouble++;
          errorElement.innerHTML =
            `&nbsp;Double Click!&nbsp;(${clickDiffVariable.toFixed(2)}s)` +
            `&nbsp;(${LPMDouble})`;
        }
        if (button === 2) {
          PPMDouble++;
          errorElement.innerHTML =
            `&nbsp;Double Click!&nbsp;(${clickDiffVariable.toFixed(2)}s)` +
            `&nbsp;(${PPMDouble})`;
        }
        if (button === 1) {
          SPMDouble++;
          errorElement.innerHTML =
            `&nbsp;Double Click!&nbsp;(${clickDiffVariable.toFixed(2)}s)` +
            `&nbsp;(${SPMDouble})`;
        }
        if (button === 4) {
          backDouble++;
          errorElement.innerHTML =
            `&nbsp;Double Click!&nbsp;(${clickDiffVariable.toFixed(2)}s)` +
            `&nbsp;(${backDouble})`;
        }
        if (button === 3) {
          nextDouble++;
          errorElement.innerHTML =
            `&nbsp;Double Click!&nbsp;(${clickDiffVariable.toFixed(2)}s)` +
            `&nbsp;(${nextDouble})`;
        }
      }
      incrementClicks();
      diffElement.innerHTML =
        " " + `&nbsp;(${clickDiffVariable.toFixed(2)}s)`;
      console.log(`(${clickDiffVariable.toFixed(2)}s)`);
    }
    function clickEvent(prevClickMicrotime) {
      let clickTime = microtime(true);
      let diff = clickTime - prevClickMicrotime;
      console.log(diff);
      if (diff <= debounceTime) {
        clickDiffVariable = diff;
        return true;
      }
      if (diff > 300) diff = 0;
      clickDiffVariable = diff;
      console.log(clickDiffVariable);
      return false;
    }
    mouseSection.addEventListener(
      "wheel",
      function (e) {
        e.preventDefault();
        let currentTime = microtime(true);
        let timeSinceLastChange = currentTime - prevScrollDirectionChangeTime;
        if (e.deltaY < 0) {
          // Scroll up
          scrollUp++;
          if (lastScrollDirection === "down" && timeSinceLastChange < 0.02) {
            scrollDirectionChanges++;
            scrollError.innerHTML =
              "Przewinięcie w dół!" +
              `<span id="scroll-direction-change-counter">(` +
              scrollDirectionChanges +
              `)</span>`;
          }
          if (lastScrollDirection !== "up") {
            scrollDirection.innerHTML = "&nbsp;Góra";
            scrollArrow.innerHTML = "&#8593;"; // Up arrow
            prevScrollDirectionChangeTime = currentTime;
          }
          lastScrollDirection = "up";
        } else if (e.deltaY > 0) {
          // Scroll down
          scrollDown++;
          if (lastScrollDirection === "up" && timeSinceLastChange < 0.02) {
            scrollDirectionChanges++;
            scrollError.innerHTML =
              "Przewinięcie w górę!" +
              `<span id="scroll-direction-change-counter">(` +
              scrollDirectionChanges +
              `)</span>`;
          }
          if (lastScrollDirection !== "down") {
            scrollDirection.innerHTML = "&nbsp;Dół";
            scrollArrow.innerHTML = "&#8595;"; // Down arrow
            prevScrollDirectionChangeTime = currentTime;
          }
          lastScrollDirection = "down";
        }
        MouseRenderActiveButtons(e.deltaY); // Pass deltaY here
        updateClicks();
      },
      { passive: false }
    );
    mouseSection.addEventListener("mousedown", function (e) {
      let button = e.button;
      if (button === 0) {
        // Left mouse button
        isLPMPressed = true;
        handleMouseClick(
          button,
          () => LPMClicks++,
          LPMError,
          LPMDiff,
          prevClickMicrotimeLPM
        );
        prevClickMicrotimeLPM = microtime(true);
      } else if (button === 2) {
        // Right mouse button
        isPPMPressed = true;
        handleMouseClick(
          button,
          () => PPMClicks++,
          PPMError,
          PPMDiff,
          prevClickMicrotimePPM
        );
        prevClickMicrotimePPM = microtime(true);
      } else if (button === 1) {
        // Middle mouse button
        isSPMPressed = true;
        handleMouseClick(
          button,
          () => SPMClicks++,
          SPMError,
          SPMDiff,
          prevClickMicrotimeSPM
        );
        prevClickMicrotimeSPM = microtime(true);
      } else if (button === 4) {
        // Middle mouse button
        isbackPressed = true;
        handleMouseClick(
          button,
          () => backClicks++,
          backError,
          backDiff,
          prevClickMicrotimeback
        );
        prevClickMicrotimeback = microtime(true);
      } else if (button === 3) {
        // Middle mouse button
        isnextPressed = true;
        handleMouseClick(
          button,
          () => nextClicks++,
          nextError,
          nextDiff,
          prevClickMicrotimenext
        );
        prevClickMicrotimenext = microtime(true);
      }
      MouseRenderActiveButtons();
      activeState();
      updateClicks();
      e.preventDefault();
    });
    mouseSection.addEventListener("mouseup", function (e) {
      let button = e.button;
      if (button === 0) {
        // Left mouse button
        isLPMPressed = false;
      } else if (button === 2) {
        // Right mouse button
        isPPMPressed = false;
      } else if (button === 1) {
        // Middle mouse button
        isSPMPressed = false;
      } else if (button === 4) {
        // Middle mouse button
        isbackPressed = false;
      } else if (button === 3) {
        // Middle mouse button
        isnextPressed = false;
      }
      MouseRenderActiveButtons();
      activeState();
      updateClicks();
      e.preventDefault();
    });
    mouseSection.addEventListener("contextmenu", function (e) {
      e.preventDefault();
    });
    function MouseRenderActiveButtons(deltaY) {
      console.log("MouseRenderActiveButtons:");
      console.log("  deltaY:", deltaY);
      console.log("  isLPMPressed:", isLPMPressed);
      console.log("  isPPMPressed:", isPPMPressed);
      console.log("  isSPMPressed:", isSPMPressed);
      console.log("  isbackPressed:", isbackPressed);
      console.log("  isnextPressed:", isnextPressed);

      if (isLPMPressed) {
        LPMButton.style.backgroundColor = "#ffb100cc";
      } else if (LPMDouble > 0) {
        LPMButton.style.backgroundColor = "#ff0000cc";
      } else {
        LPMButton.style.backgroundColor = "#adadad85";
      }
      if (isPPMPressed) {
        PPMButton.style.backgroundColor = "#ffb100cc";
      } else if (PPMDouble > 0) {
        PPMButton.style.backgroundColor = "#ff0000cc";
      } else {
        PPMButton.style.backgroundColor = "#adadad85";
      }
      if (isSPMPressed) {
        SPMButton.style.backgroundColor = "#ffb100cc";
      } else if (SPMDouble > 0) {
        SPMButton.style.backgroundColor = "#ff0000cc";
      } else {
        SPMButton.style.backgroundColor = "#adadad85";
      }
      if (isbackPressed) {
        backButton.style.backgroundColor = "#ffb100cc";
      } else if (backDouble > 0) {
        backButton.style.backgroundColor = "#ff0000cc";
      } else {
        backButton.style.backgroundColor = "#adadad85";
      }
      if (isnextPressed) {
        nextButton.style.backgroundColor = "#ffb100cc";
      } else if (nextDouble > 0) {
        nextButton.style.backgroundColor = "#ff0000cc";
      } else {
        nextButton.style.backgroundColor = "#adadad85";
      }
      if (deltaY < 0) {
        scrollRoller.innerHTML = "&#8593;";
        SPMButton.style.backgroundColor = "#ffb10036";
      } else if (deltaY > 0) {
        scrollRoller.innerHTML = "&#8595;";
        SPMButton.style.backgroundColor = "#ffb10036";
      } else {
        scrollRoller.innerHTML = "";
        SPMButton.style.backgroundColor = "#191919cc";
      }
      // Reset SPMButton color after 1 second
      setTimeout(() => {
        if (SPMDouble > 0 || scrollDirectionChanges > 0) {
          SPMButton.style.backgroundColor = "#ff0000cc";
        } else {
          SPMButton.style.backgroundColor = "#000000cc";
        }
      }, 5);
    }
    function updateClicks() {
      LPMCounter.innerHTML = `&nbsp;` + LPMClicks;
      PPMCounter.innerHTML = `&nbsp;` + PPMClicks;
      SPMCounter.innerHTML = `&nbsp;` + SPMClicks;
      backCounter.innerHTML = `&nbsp;` + backClicks;
      nextCounter.innerHTML = `&nbsp;` + nextClicks;
      scrollUpCounter.innerHTML = `&nbsp;` + scrollUp;
      scrollDownCounter.innerHTML = `&nbsp;` + scrollDown;
    }
    function activeState() {
      if (
        isLPMPressed ||
        isPPMPressed ||
        isSPMPressed ||
        isbackPressed ||
        isnextPressed
      ) {
        document.getElementById("testareaText").style.backgroundColor =
          "#ffb100aa";
      } else {
        document.getElementById("testareaText").style.backgroundColor =
          "#007bff";
      }
    }
    updateClicks();
    setDebounceTime();
    MouseRenderActiveButtons();
    function microtime(get_as_float) {
      const now = new Date().getTime() / 1000;
      const s = parseInt(now, 10);
      return get_as_float
        ? now
        : Math.round((now - s) * 1000) / 1000 + " " + s;
    }
    function updateCount() {
      let now = performance.now();
      let elapsed = now - lastTime;

      if (elapsed >= 1000) { // Aktualizacja co 1 sekundę
        value = count / (elapsed / 1000);
        totalMoves += count;
        tick++;

        let avgValue = Math.ceil(totalMoves / tick);
        document.getElementById("hZmeter").innerHTML =
          `Aktualny: ${value.toFixed(2)} Hz, Średnia: ${avgValue} Hz`;

        count = 0;
        lastTime = now;

        if (tick > 30) { // Resetowanie co 30 sekund
          tick = 0;
          totalMoves = 0;
        }
      }
    }
    function updateChart() {
      meterSeconds++;
      chartData.labels.push(meterSeconds);
      chartData.datasets[0].data.push(value);

      if (chartData.labels.length > 80) {
        chartData.labels.shift();
        chartData.datasets[0].data.shift();
      }
      myChart.update();
    }


    function valloop(event) {
      let events = "getCoalescedEvents" in event ? event.getCoalescedEvents() : [event];
      count += events.length;
    }
    function checkRate() {
      if (timer) {
        // Zatrzymanie pomiaru
        clearInterval(timer);
        clearInterval(chartTimer);
        clearTimeout(testTimeout);
        document.removeEventListener("pointermove", valloop);
        timer = null;
        document.getElementById("meterButton").innerHTML =
          "Pomiar zakończony! Kliknij, aby rozpocząć ponownie!";
      } else {
        // Resetowanie wartości
        count = 0;
        tick = 0;
        totalMoves = 0;
        meterSeconds = 0;
        lastTime = performance.now();

        chartData.labels = [];
        chartData.datasets[0].data = [0];
        myChart.update();

        document.getElementById("hZmeter").innerHTML =
          "Aktualny: 0 Hz, Średnia: 0 Hz";
        document.getElementById("meterButton").innerHTML =
          "Pomiar rozpoczęty! Ruszaj myszką!";
        document.getElementById("myChart").style.display = "flex";

        document.addEventListener("pointermove", valloop);

        timer = setInterval(updateCount, 100);
        chartTimer = setInterval(updateChart, 1000);

        testTimeout = setTimeout(() => {
          clearInterval(timer);
          clearInterval(chartTimer);
          document.removeEventListener("pointermove", valloop);
          timer = null;
          document.getElementById("meterButton").innerHTML =
            "Pomiar zakończony! Kliknij, aby rozpocząć ponownie!";
        }, 30000);
      }
    }

    // Funkcja do ustawiania ciasteczek
    function setCookie(name, value, days) {
      const date = new Date();
      date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
      document.cookie = `${name}=${value};expires=${date.toUTCString()};path=/`;
    }

    // Funkcja do pobierania ciasteczek
    function getCookie(name) {
      const cookies = document.cookie.split("; ");
      for (let i = 0; i < cookies.length; i++) {
        const [key, value] = cookies[i].split("=");
        if (key === name) {
          return value;
        }
      }
      return null;
    }

    // Funkcja do wyświetlania powiadomień o osiągnięciach
    function showAchievementPopup(name, level) {
      const container = document.getElementById("achievement-popup-container");

      // Dobieramy kolor dla poziomu
      let color = "";
      if (level === "bronze") color = "#cd7f32";
      else if (level === "silver") color = "#c0c0c0";
      else if (level === "gold") color = "#ffd700";

      const popup = document.createElement("div");
      popup.className = "achievement-popup";
      popup.innerHTML = `
    <img src="https://cdn-icons-png.flaticon.com/512/847/847969.png" alt="Achievement Icon">
    <div class="text">
      Osiągnięcie odblokowane: <strong>${name}</strong><br>
      Poziom: <strong style="color:${color}">${level}</strong>
    </div>
    <div class="close" onclick="this.parentElement.remove()">×</div>
  `;
      container.appendChild(popup);

      // Po 5 sekundach uruchom animację chowania, a następnie usuń element
      setTimeout(() => {
        popup.style.animation = "slide-out 0.5s ease forwards"; // Animacja chowania
        popup.addEventListener("animationend", () => {
          popup.remove();
        });
      }, 5000);
    }

    // Funkcja do wywoływania fajerwerków
    function triggerFireworks() {
      const container = document.getElementById("fireworks-container");

      for (let i = 0; i < 80; i++) {
        const firework = document.createElement("div");
        firework.className = "firework";
        firework.style.left = `${Math.random() * 100}%`;
        firework.style.top = `${Math.random() * 100}%`;
        firework.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;

        container.appendChild(firework);

        // Usunięcie fajerwerku po zakończeniu animacji
        setTimeout(() => {
          firework.remove();
        }, 3000);
      }
    }

    // Funkcja do wczytywania zapisanych osiągnięć z ciasteczka
    function loadAchievements() {
      const cookie = getCookie("achievements");
      if (cookie) {
        try {
          return JSON.parse(cookie);
        } catch (e) {
          return [];
        }
      }
      return [];
    }

    // Funkcja do zapisywania osiągnięć w ciasteczku
    function saveAchievements(achievementsArr) {
      setCookie("achievements", JSON.stringify(achievementsArr), 365);
    }

    // Inicjujemy cookie osiągnięć (tablicę identyfikatorów)
    let unlockedAchievements = loadAchievements();

    // Lista osiągnięć z przypisanymi poziomami
    const achievements = [
      { id: "firstClick", name: "Pierwsze kliknięcie!", condition: () => LPMClicks > 0, level: "bronze" },
      { id: "tenClicks", name: "10 kliknięć!", condition: () => LPMClicks >= 10, level: "bronze" },
      { id: "hundredClicks", name: "100 kliknięć!", condition: () => LPMClicks >= 100, level: "silver" },
      { id: "firstScroll", name: "Pierwsze przewinięcie!", condition: () => scrollUp > 0 || scrollDown > 0, level: "bronze" },
      { id: "fiftyScrolls", name: "50 przewinięć!", condition: () => scrollUp + scrollDown >= 50, level: "silver" },
      { id: "firstDoubleClick", name: "Pierwszy podwójny klik!", condition: () => LPMDouble > 0, level: "bronze" },
      { id: "maxFrequency100", name: "Częstotliwość 100 Hz!", condition: () => value >= 100, level: "bronze" },
      { id: "maxFrequency500", name: "Częstotliwość 500 Hz!", condition: () => value >= 500, level: "silver" },
      { id: "maxFrequency1000", name: "Częstotliwość 1000 Hz!", condition: () => value >= 1000, level: "gold" },
      { id: "testComplete", name: "Test ukończony!", condition: () => timer === null && tick > 0, level: "silver" },
      { id: "thirtySeconds", name: "30 sekund testu!", condition: () => meterSeconds >= 30, level: "bronze" },
      { id: "scrollMaster", name: "Mistrz scrollowania!", condition: () => scrollUp + scrollDown >= 200, level: "silver" },
      { id: "clickMaster", name: "Mistrz kliknięć!", condition: () => LPMClicks + PPMClicks + SPMClicks >= 500, level: "gold" },
      { id: "jumpScrollFan", name: "Fan Jump Scrolla!", condition: () => scrollDirectionChanges >= 30, level: "silver" },
      { id: "backButtonMaster", name: "Mistrz przycisku wstecz!", condition: () => backClicks >= 50, level: "bronze" },
      { id: "nextButtonMaster", name: "Mistrz przycisku dalej!", condition: () => nextClicks >= 50, level: "bronze" },
      { id: "doubleClickMaster", name: "Mistrz podwójnych kliknięć!", condition: () => LPMDouble + PPMDouble + SPMDouble >= 50, level: "silver" },
      { id: "backButtonDoubleMaster", name: "Mistrz podwójnych kliknięć wstecz!", condition: () => backDouble >= 50, level: "silver" },
      { id: "nextButtonDoubleMaster", name: "Mistrz podwójnych kliknięć dalej!", condition: () => nextDouble >= 50, level: "silver" },
      { id: "scrollUpFan", name: "Fan przewijania w górę!", condition: () => scrollUp >= 500, level: "bronze" },
      { id: "scrollDownFan", name: "Fan przewijania w dół!", condition: () => scrollDown >= 500, level: "bronze" },
      { id: "scrollUpClickMaster", name: "Mistrz przewijania w górę i kliknięć!", condition: () => scrollUp + LPMClicks >= 1000, level: "silver" },
      { id: "scrollDownClickMaster", name: "Mistrz przewijania w dół i kliknięć!", condition: () => scrollDown + PPMClicks >= 1000, level: "silver" },
      { id: "clickScrollMaster", name: "Mistrz kliknięć i przewijania!", condition: () => LPMClicks + PPMClicks >= 1000, level: "gold" },
      { id: "clickScrollFan", name: "Fan kliknięć i przewijania!", condition: () => LPMClicks + PPMClicks >= 2000, level: "gold" },
      { id: "scrollUpClickFan", name: "Fan przewijania w górę i kliknięć!", condition: () => scrollUp + LPMClicks >= 2000, level: "gold" },
      { id: "scrollDownClickFan", name: "Fan przewijania w dół i kliknięć!", condition: () => scrollDown + PPMClicks >= 2000, level: "gold" },
      { id: "clickScrollMasterFan", name: "Mistrz kliknięć i przewijania!", condition: () => LPMClicks + PPMClicks >= 5000, level: "gold" },
      { id: "clickScrollFanMaster", name: "Fan kliknięć i przewijania!", condition: () => LPMClicks + PPMClicks >= 10000, level: "gold" },
      { id: "scrollUpMaster", name: "Mistrz przewijania w górę!", condition: () => scrollUp >= 1000, level: "silver" },
      { id: "scrollDownMaster", name: "Mistrz przewijania w dół!", condition: () => scrollDown >= 1000, level: "silver" },
      { id: "allAchievements", name: "Wszystkie osiągnięcia odblokowane!", condition: () => unlockedAchievements.length === achievements.length, level: "gold" }
    ];

    // Tablica do śledzenia wyświetlonych osiągnięć w bieżącej sesji
    const displayedAchievements = new Set();
    const achievementQueue = []; // Kolejka osiągnięć
    let isAchievementDisplayed = false; // Flaga, czy aktualnie jest wyświetlane osiągnięcie

    // Funkcja do sprawdzania i przyznawania osiągnięć
    function checkAchievements() {
      achievements.forEach((achievement) => {
        // Sprawdzamy, czy warunek jest spełniony oraz czy dany achievement nie został już odblokowany
        if (achievement.condition() &&
          !displayedAchievements.has(achievement.id) &&
          !unlockedAchievements.includes(achievement.id)) {
          // Dodaj osiągnięcie do kolejki
          achievementQueue.push(achievement);
          displayedAchievements.add(achievement.id);
          // Zapisz osiągnięcie w globalnej tablicy cookie
          unlockedAchievements.push(achievement.id);
          saveAchievements(unlockedAchievements);
        }
      });

      // Jeśli nie ma obecnie wyświetlanego osiągnięcia, wyświetl następne z kolejki
      if (!isAchievementDisplayed && achievementQueue.length > 0) {
        displayNextAchievement();
      }
    }

    // Funkcja do wyświetlania następnego osiągnięcia z kolejki
    function displayNextAchievement() {
      if (achievementQueue.length === 0) {
        isAchievementDisplayed = false;
        return;
      }
      isAchievementDisplayed = true;
      const nextAchievement = achievementQueue.shift();
      showAchievementPopup(nextAchievement.name, nextAchievement.level);
      // Po 5 sekundach wyświetl kolejne osiągnięcie z kolejki
      setTimeout(() => {
        isAchievementDisplayed = false;
        displayNextAchievement();
      }, 5000);
    }

    // Wywołanie funkcji sprawdzającej osiągnięcia co sekundę
    setInterval(checkAchievements, 1000);

    // Funkcja do pobrania obiektu osiągnięcia na podstawie id
    function getAchievementById(id) {
      return achievements.find(ach => ach.id === id);
    }

    // Funkcja aktualizująca listę osiągnięć w panelu podglądu
    function updateAchievementsPreview() {
      const list = document.getElementById("achievements-preview-list");
      list.innerHTML = "";
      // Wczytujemy odblokowane osiągnięcia z cookie (tablica strings)
      let unlocked = loadAchievements();
      unlocked.forEach(id => {
        const ach = getAchievementById(id);
        if (ach) {
          let color = "";
          if (ach.level === "bronze") color = "#cd7f32";
          else if (ach.level === "silver") color = "#c0c0c0";
          else if (ach.level === "gold") color = "#ffd700";
          const li = document.createElement("li");
          li.style.marginBottom = "5px";
          li.innerHTML = `<strong style="color:${color}">${ach.name}</strong> (${ach.level})`;
          list.appendChild(li);
        }
      });
    }

    // Funkcja do przełączania widoczności panelu podglądu osiągnięć
    function toggleAchievementsPreview() {
      const preview = document.getElementById("achievements-preview-container");
      if (preview.style.display === "none" || preview.style.display === "") {
        updateAchievementsPreview();
        preview.style.display = "block";
        document.getElementById("toggle-preview-btn").style.display = "none";
      } else {
        preview.style.display = "none";
        document.getElementById("toggle-preview-btn").style.display = "block";
      }
    }

    // Funkcja do wyświetlania osiągnięć w modalu
    function showAchievementsModal() {
      const achievementsList = document.getElementById("achievements-list");
      achievementsList.innerHTML = ""; // Wyczyść listę przed dodaniem nowych elementów

      // Pobierz odblokowane osiągnięcia z ciasteczek
      const unlocked = loadAchievements();

      if (unlocked.length === 0) {
        // Jeśli brak odblokowanych osiągnięć
        const noAchievementsItem = document.createElement("li");
        noAchievementsItem.className = "list-group-item text-center";
        noAchievementsItem.textContent = "Brak odblokowanych osiągnięć.";
        achievementsList.appendChild(noAchievementsItem);
      } else {
        // Dodaj każde osiągnięcie do listy
        unlocked.forEach((id) => {
          const achievement = getAchievementById(id);
          if (achievement) {
            const listItem = document.createElement("li");
            listItem.className = "list-group-item d-flex justify-content-between align-items-center";

            // Kolor poziomu osiągnięcia
            let color = "";
            if (achievement.level === "bronze") color = "#cd7f32";
            else if (achievement.level === "silver") color = "#c0c0c0";
            else if (achievement.level === "gold") color = "#ffd700";

            listItem.innerHTML = `
              <span><strong>${achievement.name}</strong></span>
              <span style="color: ${color}; font-weight: bold;">${achievement.level}</span>
            `;
            achievementsList.appendChild(listItem);
          }
        });
      }

      // Wyświetl modal
      const achievementsModal = new bootstrap.Modal(document.getElementById("achievementsModal"));
      achievementsModal.show();
    }

    function resetAchievements() {
      if (confirm("Czy na pewno chcesz zresetować wszystkie osiągnięcia?")) {
        setCookie("achievements", "", -1);
        unlockedAchievements = [];
        const achievementsList = document.getElementById("achievements-list");
        achievementsList.innerHTML = "";

        const noAchievementsItem = document.createElement("li");
        noAchievementsItem.className = "list-group-item text-center";
        noAchievementsItem.textContent = "Brak odblokowanych osiągnięć.";
        achievementsList.appendChild(noAchievementsItem);

        console.log("Osiągnięcia zostały zresetowane.");
      }
    }
  </script>
</body>

</html>
